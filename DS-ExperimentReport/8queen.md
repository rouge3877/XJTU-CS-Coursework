# 实验4：八皇后问题

## 题目描述

设在初始状态下在国际象棋的棋盘上没有任何棋子（这里的棋子指皇后棋子）。然后顺序在第1行，第2行……第8行上布放棋子。在每一行中共有8个可选择的位置，但在任一时刻棋盘的合法布局都必须满足3个限制条件：1) 任意两个棋子不得放在同一行；2) 任意两个棋子不得放在同一列上；3) 任意棋子不得放在同一正斜线和反斜线上。

## 解题思想

这段代码是典型的N皇后问题的求解代码，采用了回溯法。具体来说，代码采用了枚举-剪枝的思路。

1. **枚举：**通过两个嵌套循环，在每一行中枚举皇后的放置位置（列），这是一个典型的穷举过程。
2. **剪枝：**在每个位置尝试放置皇后之前，通过检查当前位置所在的列、主对角线和副对角线是否已经有皇后，来判断是否可以放置。如果某一列、主对角线或副对角线已经有皇后，就不再尝试在该位置放置皇后，直接进行下一次枚举。剪枝的过程通过 `if (!cols[col] && !diags1[diag1] && !diags2[diag2])` 实现，其中 `cols` 数组记录每一列是否有皇后，`diags1` 和 `diags2` 数组记录两个方向的对角线上是否有皇后。
3. **回溯：**如果在某个位置放置皇后后，继续递归调用函数，处理下一行。如果发现在下一行无法找到合适位置，就会回溯到当前行，将当前位置的皇后移除，继续尝试下一个位置。
4. **记录解：**当找到一种合法的放置方式时，将当前的棋盘状态保存下来，以备最后输出所有的解。
5. **输出解：**在 `main` 函数中，通过循环遍历保存的所有解，输出每一种解的棋盘状态。

这种枚举-剪枝的思路通过递归的方式在搜索过程中排除了不符合条件的情况，从而减少了搜索的空间，提高了求解效率。由于 N 皇后问题的搜索空间较大，采用回溯法进行枚举和剪枝是一个常见的解法。

## 大致的算法

当解决 N 皇后问题时，"枚举"和"剪枝"是解决问题的两个核心步骤。

### 枚举：

枚举是指通过循环逐一尝试所有可能的情况，即列举出问题的所有可能解。在 N 皇后问题中，我们需要枚举每一行皇后的放置位置，以找到合适的布局方案。

```c
for (int col = 0; col < n; col++) {
    // 尝试在当前行的每一列放置皇后
}
```

这个循环用于枚举每一行皇后可以放置的列，相当于逐一尝试在每一列放置皇后，以找到合适的位置。

### 剪枝：

剪枝是为了在搜索的过程中减少无效的搜索空间，即通过判断当前情况是否符合要求，如果不符合就提前终止或跳过某些分支的搜索。

在 N 皇后问题中，为了剪枝，我们需要检查当前位置是否符合皇后放置的规则。主要包括三个方面：

**列冲突：** 不能在同一列放置多个皇后。

```C
if (!cols[col]) {
    // 当前列没有皇后，可以尝试放置
}
```

**主对角线冲突：** 不能在同一条主对角线上放置多个皇后。

```c
int diag1 = col - row + n - 1;
if (!diags1[diag1]) {
    // 当前主对角线没有皇后，可以尝试放置
}
```

**副对角线冲突：** 不能在同一条副对角线上放置多个皇后。

 ```c
int diag2 = col + row;
if (!diags2[diag2]) {
    // 当前副对角线没有皇后，可以尝试放置
}
 ```

如果当前位置满足以上三个条件，说明可以在该位置放置皇后。然后递归调用下一行的放置，否则直接跳过当前位置，继续尝试下一个位置。

```c
if (!cols[col] && !diags1[diag1] && !diags2[diag2]) {
    // 当前位置可以放置皇后
    // ...
    backTrack(n, row + 1, cols, diags1, diags2, this_state, res_states, res_index);
    // ...
}
```

这种剪枝策略有助于提前排除不符合规则的情况，减小了搜索空间，提高了算法的效率。

## 输入输出

### 对输入输出的处理

对输入输出的处理与实验1中类似：**命令行参数（argc、argv）：**

* 如果命令行参数个数为1，则输出到标准输出(stdout)。
* 如果命令行参数个数为2，且第一个参数不是"--help"，则将输出重定向到指定文件。

### 输入输出样例

#### 输入样例1

样例 1：标准输出

```bash
./EightQueens 
```

* 输出：将问题的解答输出到标准输出。

#### 输出样例1

```bash
# 省略上面的部分
--------Plan 90 end.--------

Plan 91:
   0 1 2 3 4 5 6 7 
   -----------------
0 |              # |
1 |    #           |
2 |#               |
3 |          #     |
4 |  #             |
5 |        #       |
6 |            #   |
7 |      #         |
   -----------------
--------Plan 91 end.--------

Plan 92:
   0 1 2 3 4 5 6 7 
   -----------------
0 |              # |
1 |      #         |
2 |#               |
3 |    #           |
4 |          #     |
5 |  #             |
6 |            #   |
7 |        #       |
   -----------------
--------Plan 92 end.--------


*******TOTAL 92 PLANS*******
```

#### 输入样例2

样例 2：输出至文件

```bash
./EightQueens ouput.txt
```

* 输出：将问题的解答输出到`output.txt`

#### 输出样例2

略，与输出样例1一致

#### 输入样例3

```bash
./EightQueens --help
```

#### 输出样例3

```
Usage: ./EightQueens [output_file]
If output_file is omitted, the program writes to standard output.
```

## 总结

### 时间复杂度分析：

该算法的时间复杂度主要由回溯算法决定。在最坏情况下，需要考虑所有可能的八皇后布局，因此时间复杂度为 $O(N!)$，其中 N 为皇后的数量。

### 空间复杂度分析：

1. **`backTrack` 函数：**额外使用了存储当前状态的二维布尔数组 `this_state`，其空间复杂度为 $O(N^2)$。使用了存储所有解的三维布尔数组 `res_states`，其空间复杂度为 $O(N^3)$。递归调用的深度最多为 N，因此递归调用栈的空间复杂度为$ O(N)$。

   总的空间复杂度为 $O(N^3 + N^2 + N) = O(N^3)$

2. **`createBoard `函数：**使用了一个二维布尔数组 `board`，其空间复杂度为 $O(N^2)$。

3. **`printBoard `函数：**没有使用额外的空间，只是打印输出。

4. **`eightQueens` 函数：**

   * 使用了存储棋盘状态的二维布尔数组 `checkerboard`，其空间复杂度为 $O(N^2)$。
   * 使用了三个一维布尔数组 `cols`、`diag1`、`diag2`，其空间复杂度为 $O(N)$。

   总的空间复杂度为 $O(N^2 + N) = O(N^2)$

### 可以改进的空间：

1. **使用一维数组代替二维数组：**在 `backTrack` 函数中，使用了二维数组 `this_state` 表示当前状态，可以考虑使用一维数组代替。由于每次只处理一行，可以用一个一维数组表示当前行的皇后位置。
2. **避免使用动态分配的数组：**在 `backTrack` 函数中，使用了动态分配的数组 `res_states` 用于存储所有解，但这样会导致额外的内存分配和释放。可以考虑使用栈空间或者其他方式避免动态分配。
3. **递归调用的优化：**考虑对递归调用进行优化，避免过深的递归栈。可能通过迭代或其他手段进行优化。

这些改进可以在一定程度上减小程序的空间复杂度，提高效率。

------------------------

